### 函数与参数

#### 函数的定义

> 关键字 def
>
> return 随时返回函数结果, 执行到return时, 停止执行函数内余下的语句
>
> 空函数 pass 占位符 先让代码跑起来
>
> 函数可作为参数来使用

##### 返回形式

返回对象数目与实际返回对象的关系

| 返回对象数目 | 实际返回对象 |
| :----------: | :----------: |
|      0       |     None     |
|      1       |    object    |
|      >1      |    tuple     |



#### 参数

##### 参数处理的两种方式

> 1. 值传递
>
>    参数: 基本数据类型
>
>    内涵: 指向新的引用对象 变量传递给函数后, 函数在内存中复制一个新的变量, 不影响原有变量
>
> 2. 指针传递
>
>    参数: list
>
>    内涵: 原引用对象被改变 变量传递给函数的是指针, 指针指向序列在内存中的位置, 在函数中对list的操作, 在原有内存中进行, 从而影响原有变量

##### 参数传递方式

1. ###### 位置传递

   > 依次传入参数, 位置参数/必选参数

2. ###### 关键字传递

   > 声明了**默认值**的参数, 默认参数
   >
   > 参数默认值必须指向**不变对象**

3. ###### 包裹传递(可变参数)

   > 传入**个数不定**的参数组
   >
   > ​	元组: 非关键字参数
   >
   > ​	字典: 关键字参数
   >
   > ###### 方式
   >
   > 包裹位置参数 (非关键字可变长参数: 元组)
   >
   > 包裹关键字参数 (关键字参数: 字典)

   ```python
   # 方式一: 包裹位置参数 (非关键字可变长参数: 元组)
   
   # 定义函数
   def func(*tuple_names):
       """
       封装成元组, 任意数量的位置参数
       :param tuple_names: 收集所有的参数, 根据位置合并成一个tuple
       :return:
       """
       print(tuple_names)
       return
   
   
   if __name__ == '__main__':
       # 使用函数
       a = [1, 3, 5]
       # list/tuple前加*
       func(*a)  # 输出(1, 3, 5)
   
       # 或者直接传入一串值
       func(1, 2, 3)  # 输出(1, 2, 3)
   ```

   ```python
   # 方式二: 包裹关键字参数 (关键字参数: 字典)
   
   # 定义函数
   def func(**dict_name):
       """
       任意数量参数封装成字典, 允许参数缺失, 不按顺序
       :param dict_name: 收集所有的参数, 封装成一个字典
       :return:
       """
       print(dict_name)
       return
   
   
   if __name__ == '__main__':
       # 使用函数
       a = {'a': 1, 'b': 2}
       # dict前加**
       func(**a)  # 输出{'a': 1, 'b': 2}
   
       # 或者直接传入多个键值对
       func(a=3, b=4)  # 输出{'a': 3, 'b': 4}
   ```

   ###### 3-1.解包裹

   形如 func(*args, **kwargs):

   > 首先拆解args, 按顺序传给必选参数-默认参数-可变参数(如果还有值剩余), 再拆解给kwargs, 传给关键字参数
   >
   > *, ** 用来拆解 list/tuple & dict
   >
   > func(*args)  tuple的每一个元素, 对应一个**位置参数**
   >
   > func(**kwargs)  字典的每个键值对, 作为一个关键字参数

   包裹在定义函数时使用, 解包裹在使用函数时使用。两个操作是相互独立的过程, 并非相反操作

#### 装饰器

> 在代码运行期间给函数动态增加功能
>
> 本质上, 一个返回函数的高阶函数
>
> 应用: 引入日志, 增加计时功能, 检测性能

```python
# 装饰器函数 可以接受任意参数的调用
def log(func):
    def wrapper(*args, **kwargs):
        print("call %s():" % func.__name__)
        return func(*args, **kwargs)

    return wrapper


# 使用装饰器 @log放到now()函数定义处 相当于now=log(now)
@log
def now():
    print("14:33")


if __name__ == '__main__':
    now()

# 输出
# call now():
# 14: 33
```

